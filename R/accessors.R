# read_fsa ----------------------------------------------------------------

#' Read fsa file
#'
#' This function is just a wrapper of seqinr::read.abif
#'
#' @param files a chr vector of fsa file names.
#'
#' @return A list of ABIF formatted files generated by seqinr::read.abif(). List
#' elements are named by the file name.
#' @seealso [seqinr::read.abif()]
#' @export
#' @importFrom seqinr read.abif
#'
#' @examples
#' # files <- list.files("example_directory/", full.names = TRUE, pattern = ".fsa")
#' # read_fsa(files)
#'
read_fsa <- function(files) {
  # make sure file extension is fsa
  unique_file_ext <- unique(tools::file_ext(files))
  if (length(unique_file_ext) > 1) {
    stop("Files must be only be .fsa")
  }
  if (unique_file_ext != "fsa") {
    stop("Files must be .fsa")
  }

  # read in samples
  file_list <- list()
  for (i in seq_along(files)) {
    file_list[[i]] <- seqinr::read.abif(files[i])
  }

  unique_names <- make.unique(basename(files))

  names(file_list) <- unique_names

  return(file_list)
}


# ladder ------------------------------------------------------------------


#' Ladder and bp sizing
#'
#' Find the ladder peaks in the fsa file and use that to call bp size
#'
#' @param fsa_list list from 'read_fsa' function
#' @param ladder_channel string: which channel in the fsa file contains the
#'        ladder signal
#' @param signal_channel string: which channel in the fsa file contains the data
#'        signal
#' @param ladder_sizes numeric vector: bp sizes of ladder used in fragment analysis.
#'        defaults to GeneScan™ 500 LIZ™
#' @param spike_location numeric: indicate the scan number to start looking for
#'        ladder peaks. Usually this can be automatically found (when set to NULL) since
#'        there's a big spike right at the start. However, if your ladder peaks
#'        are taller than the big spike, you will need to set this starting scan
#'        number manually.
#' @param minimum_peak_signal numeric: minimum height of peak from smoothed signal.
#' @param zero_floor logical: if set to TRUE, all negative values will be set to zero.
#'        This can help deal with cases where there are peaks in the negative direction
#'        that interfere with peak detection.
#' @param scan_subset numeric vector (length 2): filter the ladder and data signal
#'        between the selected scans (eg scan_subset = c(3000, 5000)).
#'        to pracma::savgol().
#' @param max_combinations numeric: what is the maximum number of ladder
#'        combinations that should be tested
#' @param ladder_selection_window numeric: in the ladder assigning algorithm,
#'        the we iterate through the scans in blocks and test their linear fit ( We can assume that the ladder is linear over a short distance)
#'        This value defines how large that block of peaks should be.
#' @param smoothing_window numeric: ladder signal smoothing window size passed
#' @param show_progress_bar show progress bar
#'
#' @return list of fragments_trace objects
#' @export
#'
#' @details
#' This function takes a list of fsa files (the output from read_fsa) and identifies
#' the ladders in the ladder channel which is used to call the bp size. The output
#' is a list of fragments_traces. bp sizes are assigned using the local Southern
#' method. Basically, for each data point, linear models are made for the lower
#' and upper 3 size standard and the predicted sizes are averaged.
#'
#' The ladder peaks are assigned from largest to smallest. I would recommend excluding
#' size standard peaks less than 50 bp (eg size standard 35 bp).
#'
#' Each ladder should be manually inspected to make sure that is has been correctly
#' assigned.
#'
#' @seealso [fix_ladders_auto()] and [fix_ladders_interactive()] to fix ladders with
#' incorrectly assigned peaks. [plot_ladders()] to plot the assigned ladder
#' peaks onto the raw ladder signal.
#'
#'
#' @examples
#'
#' file_list <- instability::cell_line_fsa_list
#'
#' test_ladders <- find_ladders(file_list)
#'
#' # Manually inspect the ladders
#' plot_ladders(test_ladders[1], n_facet_col = 1)
#'
find_ladders <- function(fsa_list,
                         ladder_channel = "DATA.105",
                         signal_channel = "DATA.1",
                         ladder_sizes = c(50, 75, 100, 139, 150, 160, 200, 250, 300, 340, 350, 400, 450, 490, 500),
                         spike_location = NULL,
                         minimum_peak_signal = NULL,
                         zero_floor = FALSE,
                         scan_subset = NULL,
                         ladder_selection_window = 5,
                         max_combinations = 2500000,
                         smoothing_window = 21,
                         show_progress_bar = TRUE) {
  ladder_list <- vector("list", length(fsa_list))
  for (i in seq_along(fsa_list)) {

    if (show_progress_bar) {
      pb <- utils::txtProgressBar(min = 0, max = length(ladder_list), style = 3)
    }

    ladder_list[[i]] <- fragments_trace$new(unique_id = names(fsa_list[i]))
    ladder_list[[i]]$raw_ladder <- fsa_list[[i]]$Data[[ladder_channel]]
    ladder_list[[i]]$raw_data <- fsa_list[[i]]$Data[[signal_channel]]
    ladder_list[[i]]$scan <- 0:(length(fsa_list[[i]]$Data[[signal_channel]]) - 1)
    ladder_list[[i]]$off_scale_scans <- fsa_list[[i]]$Data$OfSc.1


    ladder_list[[i]] <- find_ladder_helper(
        fragments_trace = ladder_list[[i]],
        ladder_channel = ladder_channel,
        signal_channel = signal_channel,
        ladder_sizes = ladder_sizes,
        spike_location = spike_location,
        zero_floor = zero_floor,
        scan_subset = scan_subset,
        smoothing_window = smoothing_window,
        minimum_peak_signal = minimum_peak_signal,
        max_combinations = max_combinations,
        ladder_selection_window = ladder_selection_window
      )

    if (show_progress_bar) {
      utils::setTxtProgressBar(pb, i)
    }
  }

  names(ladder_list) <- names(fsa_list)

  return(ladder_list)
}



#' Automatically fix ladders
#'
#' This function tries to automatically identify badly assigned peaks and reassign
#' them. It will only work if some consecutive peaks are correctly assigned. A good
#' function to use if only one ladder peak is wrong.
#'
#' @param fragments_trace_list list of fragments_trace objects. Output from find_ladders()
#' @param unique_ids a character vector of unique ids of samples to fix
#' @param size_threshold the bp size from the edges of the size standard to look.
#' Increase to try and fix ladder peaks further away from correctly assigned.
#' @param size_tolerance bp size for how far away prediction is from a real peak
#' to be counted as correct.
#' @param rsq_threshold R-squared threshold of linear models that represent assumed
#' correct peak assignment.
#'
#' @return a list of fragments_trace object, equal length and names to the list input
#' @export
#'
#' @details
#' This function takes a list of fragments_traces objects and tries to automatically
#' fix the ladder. It uses an assumption that some of the peaks are correct (high
#' r-squared standard linear model) and then uses those to predict
#' where the size standard should be. If the size standard is where it's expected,
#' it will be assigned, otherwise it will be dropped.
#'
#' The ladders should be manually inspected to confirm correct assignment.
#'
#' @seealso [fix_ladders_manual()] to fix ladders with incorrectly assigned peaks
#' manually. [plot_ladders()] to plot the assigned ladder peaks onto the raw ladder
#' signal.
#'
#' @examples
#'
#'
#' file_list <- instability::cell_line_fsa_list
#'
#' test_ladders <- find_ladders(file_list)
#'
#' ladders_fixed_list <- fix_ladders_auto(test_ladders, "20230413_B03.fsa")
#'
fix_ladders_auto <- function(fragments_trace_list,
                             unique_ids,
                             size_threshold = 60,
                             size_tolerance = 2.5,
                             rsq_threshold = 0.9985) {
  fragments_trace_list_2 <- vector("list", length(fragments_trace_list))
  for (i in seq_along(fragments_trace_list)) {
    if (fragments_trace_list[[i]]$unique_id %in% unique_ids) {
      fragments_trace_list_2[[i]] <- ladder_self_mod_predict(fragments_trace_list[[i]]$clone(),
                                                             size_threshold = size_threshold,
                                                             size_tolerance = size_tolerance,
                                                             rsq_threshold = rsq_threshold
      )
    } else {
      fragments_trace_list_2[[i]] <- fragments_trace_list[[i]]$clone()
    }
  }

  names(fragments_trace_list_2) <- names(fragments_trace_list)

  return(fragments_trace_list_2)
}



#' Fix ladders manually
#'
#' Manually assign the ladder peaks for samples in a fragments_trace_list
#'
#' @param fragments_trace_list list of fragments_trace objects
#' @param ladder_df_list a list of dataframes, with the names being the unique id
#' and the value being a dataframe. The dataframe has two columns, size (indicating
#' the bp of the standard) and scan (the scan value of the ladder peak). It's
#' critical that the element name in the list is the unique id of the sample.
#'
#' @return Returns a list of fragments trace objects equal to the length input
#' @export
#'
#' @details
#' This function returns a fragments_trace list the same length as was supplied.
#' It goes through each sample and either just returns the same fragments_trace
#' if the unique id doesn't match the samples that need the ladder fixed, or if
#' it is one to fix, it will use the supplied dataframe in the ladder_df_list
#' as the ladder. It then reruns the bp sizing methods on those samples.
#'
#' This is best used with [fix_ladders_interactive()] that can generate a `ladder_df_list`.
#'
#'
#' @examples
#'
#'
#' test_ladders <- find_ladders(instability::cell_line_fsa_list[1])
#'
#' # first manually determine the real ladder peaks using your judgment
#' # the raw ladder signal can be extracted
#' raw_ladder <- test_ladders[1]$raw_ladder
#'
#' # or we can look at the "trace_bp_df" to see a dataframe that includes the scan and ladder signal
#' raw_ladder_df <- test_ladders[[1]]$trace_bp_df[, c("unique_id", "scan", "ladder_signal")]
#' plot(raw_ladder_df$scan, raw_ladder_df$ladder_signal)
#'
#' # once you have figured what sizes align with which peak, make a dataframe. The
#' # fix_ladders_manual() function takes a list as an input so that multiple ladders
#' # can be fixed. Each sample would have the the list element name as it's unique id.
#'
#' example_list <- list(
#'   "20230413_A01.fsa" = data.frame(
#'     size = c(100, 139, 150, 160, 200, 250, 300, 340, 350, 400, 450, 490, 500),
#'     scan = c(1971, 2208, 2269, 2329, 2581, 2888, 3228, 3479, 3543, 3872, 4170, 4412, 4460)
#'   )
#' )
#'
#' test_ladders_fixed_manual <- fix_ladders_manual(
#'   test_ladders,
#'   example_list
#' )
#'
fix_ladders_manual <- function(fragments_trace_list,
                               ladder_df_list) {
  samples_to_fix <- names(ladder_df_list)

  fragments_trace_list_2 <- vector("list", length(fragments_trace_list))
  for (i in seq_along(fragments_trace_list)) {
    if (fragments_trace_list[[i]]$unique_id %in% samples_to_fix) {
      message(paste("Fixing ladder for", fragments_trace_list[[i]]$unique_id))

      tmp_ladder_df <- ladder_df_list[[which(names(ladder_df_list) == fragments_trace_list[[i]]$unique_id)]]

      # do some quality control of the df user supplied
      if (!any(colnames(tmp_ladder_df) == "scan") | !any(colnames(tmp_ladder_df) == "size")) {
        stop(
          call. = FALSE,
          "Dataframe must contain columns 'size' and 'scan'"
        )
      }

      fragments_trace_list_2[[i]] <-  ladder_fix_helper(
        fragments_trace_list[[i]]$clone(),
        replacement_ladder_df = tmp_ladder_df
        )

    } else {
      fragments_trace_list_2[[i]] <- fragments_trace_list[[i]]$clone()
    }
  }

  names(fragments_trace_list_2) <- names(fragments_trace_list)

  return(fragments_trace_list_2)
}


#' Fix ladders interactively
#'
#' An app for fixing ladders
#'
#' @param fragment_trace_list A list of fragments_trace objects containing fragment data
#'
#' @return interactive shiny app
#' @export
#' @details
#' This function helps you fix ladders that are incorrectly assigned. Run `fix_ladders_interactive()`
#' and provide output from `find_ladders`. In the app, for each sample, click on
#' line for the incorrect ladder size and drag it to the correct peak.
#'
#' Once you are satisfied with the ladders for all the broken samples, click the download
#' button to generate a file that has the ladder correction data. Read this file
#' back into R using readRDS, then use [fix_ladders_manual()] and supply the ladder
#' correction data as `ladder_df_list`. This allows the manually corrected data to
#' be saved and used within a script so that the correct does not need to be done
#' every time.
#'
#' @seealso [fix_ladders_manual()], [find_ladders()]
#'
#'
#' @examples
#' file_list <- instability::cell_line_fsa_list[c("20230413_B03.fsa")]
#'
#' test_ladders <- find_ladders(file_list)
#'
#' # to create an example, lets brake one of the ladders
#' brake_ladder_list <- list(
#'   "20230413_B03.fsa" = data.frame(
#'     size = c(35, 50, 75, 100, 139, 150, 160, 200, 250, 300, 340, 350, 400, 450, 490, 500),
#'     scan = c(1555, 1633, 1783, 1827, 2159, 2218, 2278, 2525, 2828, 3161, 3408, 3470, 3792,
#'              4085, 4322, 4370)
#'   )
#' )
#'
#' test_ladders_broken <- fix_ladders_manual(
#'   test_ladders,
#'   brake_ladder_list
#' )
#'
#' plot_ladders(test_ladders_broken["20230413_B03.fsa"],
#'   n_facet_col = 1
#' )
#'
#'
#' if (interactive()) {
#'   fix_ladders_interactive(test_ladders_broken)
#' }
#'
#' # once you have corrected your ladders in the app,
#' # export the data we need to incorporate that into the script:
#' # ladder_df_list <- readRDS('path/to/exported/data.rds')
#' # test_ladders_fixed <- fix_ladders_manual(test_ladders_broken, ladder_df_list)
#'
#' # plot_ladders(test_ladders_fixed["20230413_B03.fsa"],
#' #           n_facet_col = 1)
#'
fix_ladders_interactive <- function(fragment_trace_list) {
  message("To incorporate the manual corrections into your script you need to do the following:")
  message("1: read in the corrected ladder data using 'ladder_df_list <- readRDS('path/to/exported/data.rds')'")
  message("2: Run 'fix_ladders_manual(fragments_trace_list, ladder_df_list)'")

  # Launch the Shiny app with fragment_trace_list passed as a parameter
  shiny::shinyApp(
    ui = ui,
    server = function(input, output, session) {
      server_function(input, output, session, fragment_trace_list)
    }
  )
}



#' Extract traces
#'
#' Extract the raw trace from a list of fragments objects
#'
#' @param fragments_trace_list a list of fragments objects
#'
#' @return returns a dataframe of the raw trace data. Each row representing a single scan.
#' @export
#'
#' @examples
#'
#' test_ladders <- find_ladders(instability::cell_line_fsa_list[1])
#'
#' extracted_traces <- extract_trace_table(test_ladders)
#'
extract_trace_table <- function(fragments_trace_list) {
  # turn the output into a dataframe
  plate_list <- lapply(fragments_trace_list, function(x) {
    x$trace_bp_df
  })

  plate_combined_df <- do.call(rbind, plate_list)

  return(plate_combined_df)
}



# find fragments ------------------------------------------------------------




#' Find fragment peaks
#'
#' Find fragment peaks in continuous trace data and convert to fragments_repeats
#' class.
#'
#' @param fragments_trace_list A list of fragments_trace objects containing fragment data.
#' @param smoothing_window numeric: signal smoothing window size passed to pracma::savgol()
#' @param minimum_peak_signal numeric: minimum height of peak from smoothed trace
#' @param min_bp_size numeric: minimum bp size of peaks to consider
#' @param max_bp_size numeric: maximum bp size of peaks to consider
#' @param ... pass additional arguments to findpeaks, or change the default arguments
#' we set. minimum_peak_signal above is passed to findpeaks as minpeakheight, and
#' peakpat has been set to '\[+\]\{6,\}\[0\]*\[-\]\{6,\}' so that peaks with flat tops are
#' still called, see https://stackoverflow.com/questions/47914035/identify-sustained-peaks-using-pracmafindpeaks
#'
#'
#' @return a list of fragments_repeats objects, equal length and names to the list input
#' @export
#'
#' @importFrom pracma findpeaks
#' @importFrom pracma savgol
#'
#' @details
#' This function is basically a wrapper around pracma::findpeaks. As mentioned above,
#' the default arguments arguments of pracma::findpeaks can be changed by passing them
#' to find_fragments with ... .
#'
#' If too many and inappropriate peaks are being called, this may also be solved with the different repeat calling algorithms in [call_repeats()].
#'
#' @examples
#' file_list <- instability::cell_line_fsa_list
#'
#' test_ladders <- find_ladders(file_list[1])
#'
#' fragments_list <- find_fragments(test_ladders,
#'   min_bp_size = 300
#' )
#'
#'
#' # Manually inspect the ladders
#' plot_traces(fragments_list,
#'   show_peaks = TRUE, n_facet_col = 1,
#'   xlim = c(400, 550), ylim = c(0, 1200)
#' )
find_fragments <- function(fragments_trace_list,
                           smoothing_window = 21,
                           minimum_peak_signal = 20,
                           min_bp_size = 100,
                           max_bp_size = 1000,
                           ...) {
  fragments_list <- lapply(fragments_trace_list, function(x) {
    #find peak table
    df <- find_fragment_peaks(x$trace_bp_df,
                              smoothing_window = smoothing_window,
                              minimum_peak_signal = minimum_peak_signal,
                              ...
    )
    df$unique_id <- rep(x$unique_id, nrow(df))
    df <- df[which(df$size > min_bp_size & df$size < max_bp_size), ]

    #generate new class
    new_fragments_repeats <- fragments_repeats$new(unique_id = x$unique_id)
    new_fragments_repeats$trace_bp_df <- x$trace_bp_df
    new_fragments_repeats$peak_table_df <- df
    new_fragments_repeats <- transfer_metadata_helper(x, new_fragments_repeats)
    new_fragments_repeats$.__enclos_env__$private$min_bp_size <- min_bp_size
    new_fragments_repeats$.__enclos_env__$private$max_bp_size <- max_bp_size

    return(new_fragments_repeats)
  })
}


## set class from peak table ----------------------------------------------------------------

#' Convert Peak Table to Fragments_repeats class
#'
#' This function converts a peak table data frame into a list of fragments_repeats objects.
#'
#' @param df A data frame containing the peak data.
#' @param data_format The format that the data frame is in (for example, a genemapper peak table). Choose between: genemapper5, generic.
#' @param unique_id A character string specifying column name giving the unique sample id (often the file name).
#' @param peak_size_col A character string specifying column name giving the peak size.
#' @param peak_height_col A character string specifying column name giving the peak height.
#' @param min_size_bp Numeric value indicating the minimum size of the peak table to import.
#' @param max_size_bp Numeric value indicating the maximum size of the peak table to import.
#' @param dye_col Genemapper specific. A character string specifying column name indicating the dye channel.
#' @param dye_channel Genemapper specific. A character string indicating the channel to extract data from. For example, 6-FAM is often "B".
#' @param allele_col Genemapper specific. A character string specifying column name indicating the called alleles. This is often used when the peaks have been called in genemapper.
#'
#' @return A list of fragments_repeats. objects.
#'
#' @details This function takes a peak table data frame (eg. Genemapper output) and converts it into a list of fragment objects.
#' The function supports different data formats and allows specifying column names for various attributes.
#'
#' @seealso \code{\link{repeat_table_to_repeats}}
#'
#' @examples
#'
#' gm_raw <- instability::example_data
#'
#' test_fragments <- peak_table_to_fragments(
#'   gm_raw,
#'   data_format = "genemapper5",
#'   dye_channel = "B",
#'   min_size_bp = 400
#' )
#'
#' @export
peak_table_to_fragments <- function(df,
                                    data_format = NULL,
                                    peak_size_col = NULL,
                                    peak_height_col = NULL,
                                    unique_id = NULL,
                                    dye_col = NULL,
                                    dye_channel = NULL,
                                    allele_col = NULL,
                                    min_size_bp = 100,
                                    max_size_bp = 1000) {
  # check to make sure that if the user supplies a column name, that it's actually in the dataframe
  if (any(!is.null(peak_size_col), !is.null(peak_height_col), !is.null(unique_id))) {
    function_input_vector <- c(peak_size_col, peak_height_col, unique_id)
    function_input_name_vector <- c("peak_size_col", "peak_height_col", "unique_id")
    for (i in seq_along(function_input_vector)) {
      if (!any(names(df) == function_input_vector[[i]])) {
        stop(paste0(function_input_name_vector[[i]], " input '", function_input_vector[[i]], "' was not detected as a column name in the supplied dataframe. Check column names and supply the right character string for the ", function_input_name_vector[[i]], " input"),
          call. = FALSE
        )
      }
    }
  }

  # chose the tidying function
  # Use the supplied user column names if given
  if (data_format == "genemapper5") {
    df2 <- clean_genemapper5(df,
      peak_size_col = ifelse(length(peak_size_col) == 0, "Size", peak_size_col),
      peak_height_col = ifelse(length(peak_height_col) == 0, "Height", peak_height_col),
      unique_id = ifelse(length(unique_id) == 0, "Sample.File.Name", unique_id),
      dye_col = ifelse(length(dye_col) == 0, "Dye.Sample.Peak", dye_col),
      dye_channel = ifelse(length(dye_channel) == 0, "B", dye_channel),
      allele_col = ifelse(length(allele_col) == 0, "Allele", allele_col)
    )
  } else if (data_format == "generic") {
    df2 <- clean_generic(df,
      peak_size_col = peak_size_col,
      peak_height_col = peak_height_col,
      unique_id = unique_id
    )
  } else {
    stop("Data format not recognised. Choose between: genemapper5, generic",
      call. = FALSE
    )
  }

  # filter size and split up into a list of fragments
  fragments_list <-
    lapply(
      split(df2, df2$unique_id),
      function(x) {
        # filter size
        df <- x[x$size > min_size_bp & x$size < max_size_bp & !is.na(x$size), , drop = FALSE]
        # check to see if all rows removed and give warning
        if (nrow(df) == 0) {
          warning(paste0("Size filtering removed all rows for ", unique(x$unique_id)),
            call. = FALSE
          )
        }

        new_fragments_repeats <- fragments_repeats$new(unique_id = unique(x$unique_id))
        new_fragments_repeats$peak_table_df <- df

        return(new_fragments_repeats)
      }
    )

  return(fragments_list)
}


## set class from repeats table ----------------------------------------------------------------

#' Convert Repeat Table to Repeats Fragments
#'
#' This function converts a repeat table data frame into a list of fragments_repeats. class.
#'
#' @param df A data frame containing the repeat data.
#' @param unique_id A character string indicating the column name for unique identifiers.
#' @param repeat_col A character string indicating the column name for the repeats.
#' @param frequency_col A character string indicating the column name for the repeat frequencies.
#'
#' @return A list of fragments_repeats.
#'
#' @details This function takes a repeat table data frame and converts it into a list of repeats fragments.
#' The function allows specifying column names for repeats, frequencies, and unique identifiers.
#' @export
#'
#' @examples
#' repeat_table <- instability::example_data_repeat_table
#' test_fragments <- repeat_table_to_repeats(
#'   repeat_table,
#'   repeat_col = "repeats",
#'   frequency_col = "height",
#'   unique_id = "unique_id"
#' )
repeat_table_to_repeats <- function(df,
                                    unique_id,
                                    repeat_col,
                                    frequency_col) {
  # validate inputs to give good errors to user
  ## check to make sure that if the user supplies a column name, that it's actually in the dataframe
  function_input_vector <- c(repeat_col, frequency_col, unique_id)
  function_input_name_vector <- c("repeat_col", "frequency_col", "unique_id")
  for (i in seq_along(function_input_vector)) {
    if (!any(names(df) == function_input_vector[[i]])) {
      stop(paste0(function_input_name_vector[[i]], " input '", function_input_vector[[i]], "' was not detected as a column name in the supplied dataframe. Check column names and supply the right character string for the ", function_input_name_vector[[i]], " input"),
        call. = FALSE
      )
    }
  }

  names(df)[names(df) == repeat_col] <- "repeats"
  names(df)[names(df) == frequency_col] <- "height"
  names(df)[names(df) == unique_id] <- "unique_id"

  repeats_list <- lapply(
    split(df, df$unique_id),
    function(x) {
      new_fragments_repeats <- fragments_repeats$new(unique_id = unique(x$unique_id))
      new_fragments_repeats$repeat_table_df <- x
      return(new_fragments_repeats)
    }
  )


  return(repeats_list)
}

# add metadata ------------------------------------------------------------

#' Add Metadata to Fragments List
#'
#' This function adds metadata information to a list of fragments.
#'
#' @param fragments_list A list of fragment objects to which metadata will be added.
#' @param metadata_data.frame A data frame containing the metadata information.
#' @param unique_id (required) A character string indicating the column name for unique sample identifiers in the metadata.
#' @param plate_id (optional) A character string indicating the column name for plate identifiers in the metadata.  To skip, provide NA.
#' @param group_id (optional) A character string indicating the column name for sample group identifiers in the metadata. To skip, provide NA.
#' @param metrics_baseline_control (optional) A character string indicating the column name for baseline control indicators in the metadata. To skip, provide NA.
#' @param size_standard (optional) A character string indicating the column name for repeat positive control indicators in the metadata. To skip, provide NA.
#' @param size_standard_repeat_length (optional) A character string indicating the column name for repeat positive control lengths in the metadata. To skip, provide NA.
#'
#' @return A modified list of fragment objects with added metadata.
#'
#' @details This function adds specified metadata attributes to each fragment in the list.
#' It matches the unique sample identifiers from the fragments list with those in the metadata data frame.
#' To skip any of the optional columns, make parameter NA.
#'
#' @export
#'
#' @examples
#'
#' gm_raw <- instability::example_data
#' metadata <- instability::metadata
#'
#' test_fragments <- peak_table_to_fragments(gm_raw,
#'   data_format = "genemapper5",
#'   dye_channel = "B"
#' )
#'
#' test_metadata <- add_metadata(
#'   fragments_list = test_fragments,
#'   metadata_data.frame = metadata,
#'   unique_id = "unique_id",
#'   plate_id = "plate_id",
#'   group_id = "group_id",
#'   metrics_baseline_control = "metrics_baseline_control",
#'   size_standard = "size_standard",
#'   size_standard_repeat_length = "size_standard_repeat_length"
#' )
#'
#' # skip unwanted metadata by using NA
#'
#' test_metadata_skipped <- add_metadata(
#'   fragments_list = test_fragments,
#'   metadata_data.frame = metadata,
#'   unique_id = "unique_id",
#'   plate_id = "plate_id",
#'   group_id = "group_id",
#'   metrics_baseline_control = "metrics_baseline_control",
#'   size_standard = NA,
#'   size_standard_repeat_length = NA
#' )
#'
#'
#'
#'
#'
add_metadata <- function(fragments_list,
                         metadata_data.frame,
                         unique_id = "unique_id",
                         plate_id = "plate_id",
                         group_id = "group_id",
                         metrics_baseline_control = "metrics_baseline_control",
                         size_standard = "size_standard",
                         size_standard_repeat_length = "size_standard_repeat_length") {
  # validate inputs to give good errors to user
  ## check to make sure that if the user supplies a column name, that it's actually in the dataframe they supplied
  function_input_vector <- c(
    plate_id, group_id, unique_id, size_standard,
    size_standard_repeat_length, metrics_baseline_control
  )
  function_input_name_vector <- c(
    "plate_id", "group_id", "unique_id", "size_standard",
    "size_standard_repeat_length", "metrics_baseline_control"
  )
  for (i in seq_along(function_input_vector)) {
    if (!any(names(metadata_data.frame) == function_input_vector[[i]]) & !is.na(function_input_vector[[i]])) {
      stop(paste0(function_input_name_vector[[i]], " input '", function_input_vector[[i]], "' was not detected as a column name in the supplied dataframe. Check column names and supply the right character string for the ", function_input_name_vector[[i]], " input. If you don't want to add this metadata category, set '", function_input_name_vector[[i]], " = NA'"),
        call. = FALSE
      )
    }
  }
  ## check if user has any duplicated unique ids
  supplied_ids <- metadata_data.frame[, unique_id, drop = TRUE]
  if (anyDuplicated(supplied_ids) != 0) {
    stop(paste0(unique_id, " does not contain unique sample ids. The metadata must have one row per unique sample id."),
      call. = FALSE
    )
  }
  ## Give warning if samples don't have metadata
  not_in_metadata <- which(!names(fragments_list) %in% supplied_ids)
  if (length(not_in_metadata) > 0) {
    warning(
      paste0(
        "The following samples do not have a corresponding unique id in the metadata: ",
        paste0(names(fragments_list)[not_in_metadata], collapse = ", ")
      ),
      call. = FALSE
    )
  }

  ## Give warning if user tries to give a of metadata but it's not in sample list
  not_in_samples <- which(!supplied_ids %in% names(fragments_list))
  if (length(not_in_samples) > 0) {
    warning(
      paste0(
        "The following unique ids in the metadata file do not have a corresponding sample: ",
        paste0(supplied_ids[not_in_samples], collapse = ", ")
      ),
      call. = FALSE
    )
  }

  metadata_added <- lapply(
    fragments_list,
    function(x) {
      add_metadata_helper(
        fragments = x$clone(),
        metadata_data.frame = metadata_data.frame,
        unique_id = unique_id,
        plate_id = plate_id,
        group_id = group_id,
        size_standard = size_standard,
        size_standard_repeat_length = size_standard_repeat_length,
        metrics_baseline_control = metrics_baseline_control
        )
    }
  )
}



# find alleles ------------------------------------------------------------


#' Find Alleles in Fragments List
#'
#' This function identifies main alleles within each fragment in a list of fragments.
#'
#' @param fragments_list A list of fragment objects containing peak data.
#' @param number_of_peaks_to_return Number of main peaks to be returned for each fragment. Must either be 1 or 2 if a normal sized allele is also to be found.
#' @param peak_region_size_gap_threshold Gap threshold for identifying peak regions. The peak_region_size_gap_threshold is a parameter used to determine the maximum allowed gap between peak sizes within a peak region. Adjusting this parameter affects the size range of peaks that can be grouped together in a region. A smaller value makes it more stringent, while a larger value groups peaks with greater size differences, leading to broader peak regions that may encompass wider size ranges.
#' @param peak_region_height_threshold_multiplier Multiplier for the peak height threshold. The peak_region_height_threshold_multiplier parameter allows adjusting the threshold for identifying peak regions based on peak heights. Increasing this multiplier value will result in higher thresholds, making it more stringent to consider peaks as part of a peak region. Conversely, reducing the multiplier value will make the criteria less strict, potentially leading to more peaks being grouped into peak regions. It's important to note that this parameter's optimal value depends on the characteristics of the data and the specific analysis goals. Choosing an appropriate value for this parameter can help in accurately identifying meaningful peak regions in the data.
#'
#' @return A list of fragments with identified main alleles.
#'
#' @details This function finds the main alleles for each fragment in the list by identifying clusters of peaks ("peak regions")
#' with the highest signal intensities. This is based on the idea that PCR amplicons of repeats have broad peaks and PCR artififacts that help identifying the alleles.
#'  The number of peaks to be returned, and the parameters for identifying peak regions can be customized.
#'  It's important to note that both peak_region_height_threshold_multiplier and peak_region_size_gap_threshold influence the criteria for identifying peak regions, and finding the right balance between them is crucial.
#' @export
#'
#' @examples
#' file_list <- instability::cell_line_fsa_list
#'
#' test_ladders <- find_ladders(file_list[1])
#'
#' fragments_list <- find_fragments(test_ladders,
#'   min_bp_size = 300
#' )
#'
#'
#' test_alleles <- find_alleles(
#'   fragments_list = fragments_list,
#'   number_of_peaks_to_return = 1,
#'   peak_region_size_gap_threshold = 6,
#'   peak_region_height_threshold_multiplier = 1
#' )
find_alleles <- function(fragments_list,
                         number_of_peaks_to_return = 1,
                         peak_region_size_gap_threshold = 6,
                         peak_region_height_threshold_multiplier = 1) {
  main_peaks <- lapply(fragments_list, function(x) {

    x <- find_main_peaks_helper(
      fragments_repeats_class = x$clone(),
      number_of_peaks_to_return = number_of_peaks_to_return,
      peak_region_size_gap_threshold = peak_region_size_gap_threshold,
      peak_region_height_threshold_multiplier = peak_region_height_threshold_multiplier
    )

    # finally, indicate in the private part of the class that this function has been used since that is required for next steps
    x$.__enclos_env__$private$find_main_peaks_used <- TRUE

    return(x)

  })
}


# call_repeats ------------------------------------------------------------

#' Call Repeats for Fragments
#'
#' This function calls the repeat lengths for a list of fragments.
#'
#' @param fragments_list A list of fragments_repeats objects containing fragment data.
#' @param assay_size_without_repeat An integer specifying the assay size without repeat for repeat calling. Default is 87.
#' @param repeat_size An integer specifying the repeat size for repeat calling. Default is 3.
#' @param force_whole_repeat_units A logical value specifying if the peaks should be forced to be whole repeat units apart. Usually the peaks are slightly under the whole repeat unit if left unchanged.
#' @param repeat_length_correction A character specifying the repeat length correction method. Options: \code{"none"}, \code{"from_metadata"}, \code{"from_genemapper"}. Default is \code{"none"}.
#' @param repeat_calling_algorithm A character specifying the repeat calling algorithm. Options: \code{"simple"}, \code{"fft"}, or \code{"size_period"} (see details section for more information on these).
#' @param repeat_calling_algorithm_size_window_around_allele A numeric value for how big of a window around the tallest peak should be used to find the peak periodicity. Used for both \code{"fft"} and \code{"size_period"}. For \code{"fft"}, you want to make sure that this window is limited to where there are clear peaks. For \code{"size_period"}, it will not make a big difference.
#' @param repeat_calling_algorithm_peak_assignment_scan_window A numeric value for the scan window when assigning the peak. This is used for both \code{"fft"} and \code{"size_period"}. When the scan period is determined, the algorithm jumps to the predicted scan for the next peak. This value opens a window of the neighboring scans to pick the tallest in.
#' @param repeat_calling_algorithm_size_period A numeric value \code{"size_period"} algorithm to set the peak periodicity by bp size. This is the key variable to change for \code{"size_period"}. In fragment analysis, the peaks are usually slightly below the actual repeat unit size.
#'
#' @return A list of \code{"fragments_repeats"} objects with repeat data added.
#'
#' @details
#' The calculated repeat lengths are assigned to the corresponding peaks in the provided `fragments_repeats` object. The repeat lengths can be used for downstream instability analysis.
#'
#' The `simple` algorithm is just the repeat size calculated either directly, or when size standards are used to correct the repeat, it's the repeat length calculated from the model of bp vs repeat length.
#'
#' The `fft` or `size_period` algorithms both re-call the peaks based on empirically determined (`fft`) or specified (`size_period`) periodicity of the peaks. The main application of these algorithms is to solve the issue of contaminating peaks that are not expected in the expected regular pattern of peaks. The `fft` approach applies a fourier transform to the peak signal to determine the underlying periodicity of the signal. `size_period` is similar and simpler, where instead of automatically figuring out the periodicity we as users usually know the size distance between repeat units. We can use that known peroidicty to jump between peaks.
#'
#' The `force_whole_repeat_units` algorithm aims to correct for the systematic drift in fragment sizes that occurs. It calculates repeat lengths in a way that helps align peaks with the underlying repeat pattern, making the estimation of repeat lengths more reliable relative to the main peak. The calculated repeat lengths start from the main peak's repeat length and increases in increments of the specified `repeat_size`.
#'
#' @seealso [find_alleles()]
#'
#' @export
#'
#' @examples
#'
#' file_list <- instability::cell_line_fsa_list[c(90:92)]
#'
#' test_ladders <- find_ladders(file_list)
#'
#' fragments_list <- find_fragments(test_ladders,
#'   min_bp_size = 300
#' )
#'
#' test_alleles <- find_alleles(
#'   fragments_list = fragments_list
#' )
#'
#' # Simple conversion from bp size to repeat size
#' test_repeats <- call_repeats(
#'   fragments_list = test_alleles,
#'   repeat_calling_algorithm = "simple",
#'   assay_size_without_repeat = 87,
#'   repeat_size = 3
#' )
#'
#' plot_traces(test_repeats[1], xlim = c(120,170))
#'
#'
#' # use different algorithms to call the repeats to ensure only periodic peaks are called
#'
#' # fft to automatically find peak period
#' test_repeats_fft <- call_repeats(
#'   fragments_list = test_alleles,
#'   repeat_calling_algorithm = "fft",
#'   assay_size_without_repeat = 87,
#'   repeat_size = 3
#' )
#'
#' plot_traces(test_repeats_fft[1], xlim = c(120,170))
#'
#' # size_period to manually supply the peak period
#' test_repeats_size_period <- call_repeats(
#'   fragments_list = test_alleles,
#'   repeat_calling_algorithm = "size_period",
#'   repeat_calling_algorithm_size_period = 2.75,
#'   assay_size_without_repeat = 87,
#'   repeat_size = 3
#' )
#'
#' plot_traces(test_repeats_size_period[1], xlim = c(120,170))
#'
#'
#' # Use force_whole_repeat_units algorithm to make sure called
#' # repeats are the exact number of bp apart
#'
#' test_repeats_whole_units <- call_repeats(
#'   fragments_list = test_alleles,
#'   force_whole_repeat_units = TRUE,
#'   assay_size_without_repeat = 87,
#'   repeat_size = 3
#' )
#'
#' plot_traces(test_repeats_whole_units[1], xlim = c(120,170))
#'
#' # correct repeat length from metadata
#'
#' test_alleles_metadata <- add_metadata(
#'   fragments_list = test_alleles,
#'   metadata_data.frame = instability::metadata
#' )
#'
#' test_repeats_corrected <- call_repeats(
#'   fragments_list = test_alleles_metadata,
#'   repeat_length_correction = "from_metadata"
#' )
#'
#'
#' plot_traces(test_repeats_corrected[1], xlim = c(120,170))
#'
#'
#'
#'
call_repeats <- function(fragments_list,
                         assay_size_without_repeat = 87,
                         repeat_size = 3,
                         force_whole_repeat_units = FALSE,
                         repeat_length_correction = "none",
                         repeat_calling_algorithm = "simple",
                         repeat_calling_algorithm_size_window_around_allele =  repeat_size * 5,
                         repeat_calling_algorithm_peak_assignment_scan_window = 3,
                         repeat_calling_algorithm_size_period = repeat_size * 0.93

) {
  # Check to see if repeats are to be corrected
  # if so, supply the model to each of the samples in the list
  if (repeat_length_correction %in% c("from_metadata", "from_genemapper")) {
    mod <- model_repeat_length(
      fragments_list = fragments_list,
      assay_size_without_repeat = assay_size_without_repeat,
      repeat_size = repeat_size,
      repeat_length_correction = repeat_length_correction
    )

    for (i in seq_along(fragments_list)) {
      fragments_list[[i]]$.__enclos_env__$private$correction_mod <- mod$correction_mods
      fragments_list[[i]]$.__enclos_env__$private$controls_repeats_df <- mod$controls_repeats_df
    }
  }

  # call repeats for each sample
  added_repeats <- lapply(
    fragments_list,
    function(x) {
        x <- add_repeats_helper(
          x,
          assay_size_without_repeat = assay_size_without_repeat,
          repeat_size = repeat_size,
          repeat_calling_algorithm = repeat_calling_algorithm,
          repeat_calling_algorithm_size_window_around_allele = repeat_calling_algorithm_size_window_around_allele,
          repeat_calling_algorithm_peak_assignment_scan_window = repeat_calling_algorithm_peak_assignment_scan_window,
          repeat_calling_algorithm_size_period = repeat_calling_algorithm_size_period,
          force_whole_repeat_units = force_whole_repeat_units,
          correct_repeat_length = ifelse(repeat_length_correction == "none", FALSE, TRUE)
        )

        return(x)
    }
  )

  return(added_repeats)
}






#' Assign index peaks
#'
#' Assign index peaks in preparation for calculation of instability metrics
#'
#' @param fragments_list A list of "fragments_repeats" class objects representing
#' fragment data.
#' @param grouped Logical value indicating whether samples should be grouped to
#' share a common index peak. `FALSE` will assign the sample's own modal allele as the index peak. `TRUE` will use metadata to assign the index peak based on the modal peak of another sample. This is useful for cases like inferring repeat size of inherited alleles from mouse tail data. Requires metadata via \code{link{add_metadata()}}.
#' @param index_override_dataframe A data.frame to manually set index peaks.
#' Column 1: unique sample IDs, Column 2: desired index peaks (the order of the
#' columns is important since the information is pulled by column position rather
#' than column name). Closest peak in each sample is selected.
#'
#' @return A list of \code{"fragments_repeats"} objects with index_repeat and index_height added.
#' @details
#' A key part of several instability metrics is the index peak. This is the repeat
#' length used as the reference peak for relative instability metrics calculations, like expansion index or average repeat gain.
#' For example, this is the the inherited repeat length of a mouse, or the modal repeat length for the cell line at a starting time point.
#'
#'
#' If `grouped` is set to `TRUE`, this function groups the samples by their group_id and uses the samples set as
#' metrics_baseline_control to set the index peak. Use \code{link{add_metadata()}}
#' to set these variables.
#'
#' `index_override_dataframe` can be used to manually override these assigned index
#' repeat values (irrespective of whether `grouped` is TRUE or FALSE).
#'
#' @export
#'
#' @examples
#'
#'
#' file_list <- instability::cell_line_fsa_list
#'
#' ladder_list <- find_ladders(file_list)
#'
#' fragments_list <- find_fragments(ladder_list,
#'   min_bp_size = 300
#' )
#'
#' allele_list <- find_alleles(
#'   fragments_list = fragments_list
#' )
#' repeats_list <- call_repeats(
#'   fragments_list = allele_list
#' )
#'
#' metadata_added_list <- add_metadata(
#'   fragments_list = repeats_list,
#'   metadata_data.frame = instability::metadata
#' )
#'
#'index_assigned <- assign_index_peaks(metadata_added_list,
#'                                     grouped = TRUE)
#'
#' plot_traces(index_assigned[1], xlim = c(100,150))
#'
#'
#'
#'
#'
#'
assign_index_peaks <- function(fragments_list,
                               grouped = FALSE,
                               index_override_dataframe = NULL){

  # is it grouped and the index peak needs to be determined from another sample?
  if (grouped == TRUE) {
    fragments_list <- metrics_grouping_helper(
      fragments_list = fragments_list
    )
  } else {
    # otherwise just use the modal peak as the index peak
    fragments_list <- lapply(fragments_list, function(x) {
      x <- x$clone()
      x$index_repeat <- x$allele_1_repeat
      x$index_height <- x$allele_1_height
      x$.__enclos_env__$private$assigned_index_peak_used <- TRUE
      return(x)
    })
  }

  # override index peak with manually supplied values
  if (!is.null(index_override_dataframe)) {
    fragments_list <- metrics_override_helper(
      fragments_list = fragments_list,
      index_override_dataframe = index_override_dataframe
    )
  }

  return(fragments_list)

}



# Calculate metrics -------------------------------------------------------

#' Calculate Repeat Instability Metrics
#'
#' This function computes instability metrics from a list of fragments_repeats data objects.
#'
#' @param fragments_list A list of "fragments_repeats" objects representing fragment data.
#' @param peak_threshold The threshold for peak heights to be considered in the calculations, relative to the modal peak height of the expanded allele.
#' @param window_around_index_peak A numeric vector (length = 2) defining the range around the index peak. First number specifies repeats before the index peak, second after. For example, \code{c(-5, 40)} around an index peak of 100 would analyze repeats 95 to 140. The sign of the numbers does not matter (The absolute value is found).
#' @param percentile_range A numeric vector of percentiles to compute (e.g., c(0.5, 0.75, 0.9, 0.95)).
#' @param repeat_range A numeric vector specifying ranges of repeats for the inverse quantile computation.
#' @param grouped This parameter is here for backwards compatibility and is not intended to be used within this function. It's passed to the \code{\link{assign_index_peaks}} function, see that function for documentation.
#' @param index_override_dataframe This parameter is here for backwards compatibility and is not intended to be used within this function. It's passed to the \code{\link{assign_index_peaks}} function, see that function for documentation.
#'
#' @return A data.frame with calculated instability metrics for each sample.
#' @details
#' Each of the columns in the supplied dataframe are explained below:
#'
#' ## General Information
#' - `unique_id`: A unique identifier for the sample (usually the fsa file name).
#'
#' ## Quality Control
#' - `QC_comments`: Quality control comments.
#' - `QC_modal_peak_height`: Quality control status based on the modal peak height (Low < 500, very low < 100).
#' - `QC_peak_number`: Quality control status based on the number of peaks (Low < 20, very low < 10).
#' - `QC_off_scale`: Quality control comments for off-scale peaks. Potential peaks that are off-scale are given. However, a caveat is that this could be from any of the channels (ie it could be from the ladder channel but is the same scan as the given repeat).
#'
#' ## General sample metrics
#' - `modal_peak_repeat`: The repeat size of the modal peak.
#' - `modal_peak_height`: The height of the modal peak.
#' - `index_peak_repeat`: The repeat size of the index peak (the repeat value closest to the modal peak of the index sample).
#' - `index_peak_height`: The height of the index peak.
#' - `index_weighted_mean_repeat`: The weighted mean repeat size (weighted on the height of the peaks) of the index sample.
#' - `n_peaks_total`: The total number of peaks in the repeat table.
#' - `n_peaks_analysis_subset`: The number of peaks in the analysis subset.
#' - `n_peaks_analysis_subset_expansions`: The number of expansion peaks in the analysis subset.
#' - `min_repeat`: The minimum repeat size in the analysis subset.
#' - `max_repeat`: The maximum repeat size in the analysis subset.
#' - `mean_repeat`: The mean repeat size in the analysis subset.
#' - `weighted_mean_repeat`: The weighted mean repeat size (weight on peak height) in the analysis subset.
#' - `median_repeat`: The median repeat size in the analysis subset.
#' - `max_height`: The maximum peak height in the analysis subset.
#' - `max_delta_neg`: The maximum negative delta to the index peak.
#' - `max_delta_pos`: The maximum positive delta to the index peak.
#' - `skewness`: The skewness of the repeat size distribution.
#' - `kurtosis`: The kurtosis of the repeat size distribution.
#'
#' ## Repeat instability metrics
#' - `modal_repeat_delta`: The delta between the modal peak repeat and the index peak repeat.
#' - `average_repeat_gain`: The average repeat change: The weighted mean of the sample (weighted by peak height) subtracted by the weighted mean repeat of the index sample.
#' - `instability_index`: The instability index based on peak height and distance to the index peak. (See Lee et al., 2010, https://doi.org/10.1186/1752-0509-4-29).
#' - `instability_index_abs`: The absolute instability index. The absolute value is taken for the "Change from the main allele".
#' - `expansion_index`: The instability index for expansion peaks only.
#' - `contraction_index`: The instability index for contraction peaks only.
#' - `expansion_ratio`: The ratio of expansion peaks' heights to the main peak height. Also known as "peak proportional sum" (https://doi.org/10.1016/j.cell.2019.06.036).
#' - `contraction_ratio`: The ratio of contraction peaks' heights to the main peak height.
#' - `expansion_percentile_*`: The repeat size at specified percentiles of the cumulative distribution of expansion peaks.
#' - `expansion_percentile_for_repeat_*`: The percentile rank of specified repeat sizes in the distribution of expansion peaks.

#'
#' @export
#'
#' @examples
#' gm_raw <- instability::example_data
#' metadata <- instability::metadata
#'
#' test_fragments <- peak_table_to_fragments(gm_raw,
#'   data_format = "genemapper5",
#'   dye_channel = "B",
#'   min_size_bp = 400
#' )
#'
#' test_metadata <- add_metadata(
#'   fragments_list = test_fragments,
#'   metadata_data.frame = metadata
#' )
#'
#' test_alleles <- find_alleles(
#'   fragments_list = test_metadata,
#'   number_of_peaks_to_return = 1,
#'   peak_region_size_gap_threshold = 6,
#'   peak_region_height_threshold_multiplier = 1
#' )
#'
#'
#' test_repeats <- call_repeats(
#'   fragments_list = test_alleles,
#'   repeat_calling_algorithm = "simple",
#'   assay_size_without_repeat = 87,
#'   repeat_size = 3,
#'   repeat_length_correction = "none"
#' )
#'
#' test_assigned <- assign_index_peaks(
#'   fragments_list = test_repeats,
#'   grouped = TRUE
#' )
#'
#'
#' # grouped metrics
#' # uses t=0 samples as indicated in metadata
#' test_metrics_grouped <- calculate_instability_metrics(
#'   fragments_list = test_assigned,
#'   peak_threshold = 0.05,
#'   window_around_index_peak = c(-40, 40),
#'   percentile_range = c(0.5, 0.75, 0.9, 0.95),
#'   repeat_range = c(2, 5, 10, 20)
#' )
calculate_instability_metrics <- function(fragments_list,
                                          peak_threshold = 0.05,
                                          window_around_index_peak = c(NA, NA),
                                          percentile_range = c(0.5, 0.75, 0.9, 0.95),
                                          repeat_range = c(2, 5, 10, 20),
                                          grouped = NA,
                                          index_override_dataframe = NA
                                          ) {
  # this section is in here for backwards compatibility since the functionality of assign_index_peaks() used to happen in here but was later separated
  if(!is.na(grouped) || is.data.frame(index_override_dataframe)){

    # give the user a message to tell them to use the other function
    message("The functionalty of assigning index peaks was separated into the assign_index_peaks() function, with the parameters 'grouped' and 'index_override_dataframe' kept here for backwards compatibility. We recomend using the assign_index_peaks() function seperatly instead of whitin this function. This allows you to validate that the correct index peak was assigned before moving forward with calculation of instability metrics.")

    fragments_list <- assign_index_peaks(
      fragments_list = fragments_list,
      grouped = ifelse(!is.na(grouped), grouped, FALSE),
      index_override_dataframe = if(is.data.frame(index_override_dataframe)){
                                    index_override_dataframe
                                  } else{
                                    NULL
                                  }
    )
  }


  # calculate metrics
  metrics_list <- lapply(fragments_list, function(x) {

      # compute metrics
      metrics <- compute_metrics(
        x,
        peak_threshold = peak_threshold,
        window_around_index_peak = window_around_index_peak,
        percentile_range = percentile_range,
        repeat_range = repeat_range
      )
  })
  metrics <- do.call(rbind, metrics_list)

  # add back in any samples that were removed earlier or failed to calculate metrics (they are returned as NULL and therefore not in the dataframe)
  missing_samples <- names(fragments_list)[!names(fragments_list) %in% metrics$unique_id]
  if (length(missing_samples) > 0) {
    metrics[nrow(metrics) + seq_along(missing_samples), "unique_id"] <- missing_samples
    rownames(metrics) <- metrics$unique_id
    metrics$QC_comments <- ifelse(metrics$unique_id %in% missing_samples, "metrics could not be calculated", NA_character_)
  }

  return(metrics)
}


# Extract alleles -------------------------------------------------------

#' Extract Modal Peaks
#'
#' Extracts modal peak information from each sample in a list of fragments.
#'
#' @param fragments_list A list of fragments_repeats objects containing fragment data.
#'
#' @return A data.frame containing modal peak information for each sample.
#' @export
#'
#' @examples
#' gm_raw <- instability::example_data
#'
#' test_fragments <- peak_table_to_fragments(gm_raw,
#'   data_format = "genemapper5",
#'   dye_channel = "B",
#'   min_size_bp = 400
#' )
#'
#' test_alleles <- find_alleles(
#'   fragments_list = test_fragments,
#'   number_of_peaks_to_return = 1,
#'   peak_region_size_gap_threshold = 6,
#'   peak_region_height_threshold_multiplier = 1
#' )
#'
#' extract_alleles(test_alleles)
#'
extract_alleles <- function(fragments_list) {
  extracted <- lapply(fragments_list, function(x) {
    data.frame(
      unique_id = rep(x$unique_id, 2),
      size = c(x$allele_1_size, x$allele_2_size),
      repeats = c(x$allele_1_repeat, x$allele_2_repeat),
      height = c(x$allele_1_height, x$allele_2_height),
      peak_allele = c(1, 2)
    )
  })
  extracted_df <- do.call(rbind, extracted)

  return(extracted_df)
}

# Extract fragments -------------------------------------------------------

#' Extract All Fragments
#'
#' Extracts peak data from each sample in a list of fragments.
#'
#' @param fragments_list A list of fragments_repeats objects containing fragment data.
#'
#' @return A data.frame containing peak data for each sample.
#' @export
#'
#' @examples
#' gm_raw <- instability::example_data
#' metadata <- instability::metadata
#'
#' test_fragments <- peak_table_to_fragments(gm_raw,
#'   data_format = "genemapper5",
#'   dye_channel = "B",
#'   min_size_bp = 400
#' )
#'
#' test_metadata <- add_metadata(
#'   fragments_list = test_fragments,
#'   metadata_data.frame = metadata
#' )
#'
#' test_alleles <- find_alleles(
#'   fragments_list = test_metadata,
#'   number_of_peaks_to_return = 1,
#'   peak_region_size_gap_threshold = 6,
#'   peak_region_height_threshold_multiplier = 1
#' )
#'
#' test_repeats <- call_repeats(
#'   fragments_list = test_alleles,
#'   repeat_calling_algorithm = "simple",
#'   assay_size_without_repeat = 87,
#'   repeat_size = 3,
#'   repeat_length_correction = "none"
#' )
#'
#' extract_alleles(test_repeats)
#'
extract_fragments <- function(fragments_list) {
  suppressWarnings(
    extracted <- lapply(fragments_list, function(x) {
      if (is.null(x$peak_table_df) & is.null(x$repeat_table_df)) {
        return(NULL)
      } else if (!is.null(x$peak_table_df) & is.null(x$repeat_table_df)) {
        df_length <- nrow(x$peak_table_df)
        data.frame(
          unique_id = rep(x$unique_id, df_length),
          main_peak_size = rep(x$allele_1_size, df_length),
          main_peak_height = rep(x$allele_1_height, df_length),
          height = x$peak_table_df$height,
          size = x$peak_table_df$size,
          peak_region = x$.__enclos_env__$private$peak_regions
        )
      } else if (!is.null(x$repeat_table_df)) {
        df_length <- nrow(x$repeat_table_df)
        data.frame(
          unique_id = rep(x$unique_id, df_length),
          main_peak_repeat = rep(x$allele_1_repeat, df_length),
          main_peak_height = rep(x$allele_1_height, df_length),
          height = x$repeat_table_df$height,
          repeats = x$repeat_table_df$repeats,
          peak_region = x$.__enclos_env__$private$peak_regions
        )
      }
    })
  )
  extracted_df <- do.call(rbind, extracted)


  return(extracted_df)
}

# remove fragments -------------------------------------------------------

#' Remove Samples from List
#'
#' A convenient function to remove specific samples from a list of fragments.
#'
#' @param fragments_list A list of fragments_repeats objects containing fragment data.
#' @param samples_to_remove A character vector containing the unique IDs of the samples to be removed.
#'
#' @return A modified list of fragments with the specified samples removed.
#' @export
#'
#' @examples
#' gm_raw <- instability::example_data
#' metadata <- instability::metadata
#'
#' test_fragments <- peak_table_to_fragments(
#'   gm_raw,
#'   data_format = "genemapper5",
#'   dye_channel = "B"
#' )
#'
#' all_fragment_names <- names(test_fragments)
#'
#' # pull out unique ids of samples to remove
#' samples_to_remove <- all_fragment_names[c(1, 5, 10)]
#'
#' samples_removed <- remove_fragments(test_fragments, samples_to_remove)
#'
remove_fragments <- function(fragments_list,
                             samples_to_remove) {
  unique_ids <- vector("numeric", length = length(fragments_list))
  for (i in seq_along(fragments_list)) {
    unique_ids[[i]] <- fragments_list[[i]]$unique_id
  }
  samples_removed <- fragments_list
  suppressWarnings(
    samples_removed[which(unique_ids %in% samples_to_remove)] <- NULL
  )
  return(samples_removed)
}


# plot ladder -------------------------------------------------------------

#' Plot ladder
#'
#' Plot the ladder signal
#'
#' @param fragments_trace_list A list of fragments_trace objects containing fragment data.
#' @param n_facet_col A numeric value indicating the number of columns for faceting in the plot.
#' @param sample_subset A character vector of unique ids for a subset of samples to plot
#' @param xlim the x limits of the plot. A numeric vector of length two.
#' @param ylim the y limits of the plot. A numeric vector of length two.

#'
#' @return a plot of ladders
#' @export
#'
#' @examples
#'
#' file_list <- instability::cell_line_fsa_list
#'
#' test_ladders <- find_ladders(file_list)
#'
#' # Manually inspect the ladders
#' plot_ladders(test_ladders[1], n_facet_col = 1)
#'
plot_ladders <- function(fragments_trace_list,
                         n_facet_col = 1,
                         sample_subset = NULL,
                         xlim = NULL,
                         ylim = NULL) {
  if (!is.null(sample_subset)) {
    fragments_trace_list <- fragments_trace_list[which(names(fragments_trace_list) %in% sample_subset)]
  }

  graphics::par(mfrow = c(ceiling(length(fragments_trace_list) / n_facet_col), n_facet_col)) # Adjust layout as needed
  for (i in seq_along(fragments_trace_list)) {
    fragments_trace_list[[i]]$plot_ladder(
      xlim = xlim,
      ylim = ylim
    )
  }
  graphics::par(mfrow = c(1, 1)) # Reset the layout
}

# plot traces -------------------------------------------------------------

#' Plot sample traces
#'
#' Plot the raw trace data
#'
#' @param fragments_list A list of fragments_repeats or fragments_trace objects containing fragment data.
#' @param show_peaks If peak data are available, TRUE will plot the peaks on top of the trace as dots.
#' @param n_facet_col A numeric value indicating the number of columns for faceting in the plot.
#' @param sample_subset A character vector of unique ids for a subset of samples to plot
#' @param xlim the x limits of the plot. A numeric vector of length two.
#' @param ylim the y limits of the plot. A numeric vector of length two.
#' @param x_axis A character indicating what should be plotted on the x-axis, chose between `size` or `repeats`. If neither is selected, an assumption is made based on if repeats have been called.
#' @param height_color_threshold Threshold relative to tallest peak to color the dots (blue above, purple below).
#'
#' @return plot traces from fragments object
#' @export
#'
#' @importFrom methods is
#' @importFrom grDevices adjustcolor
#' @importFrom grDevices rgb
#' @importFrom graphics plot.new
#' @importFrom graphics points
#' @importFrom graphics segments
#' @importFrom graphics text
#' @importFrom graphics title
#' @importFrom graphics barplot
#'
#'
#' @details
#' A plot of the raw signal by bp size. Red vertical line indicates the scan was
#' flagged as off-scale. This is in any channel, so use your best judgment to determine
#' if it's from the sample or ladder channel.
#'
#' If peaks are called, green is the tallest peak, blue is peaks above the height threshold (default 5%), purple is below the height threshold. If `force_whole_repeat_units` is used within [call_repeats()], the called repeat will be connected to the peak in the trace with a horizontal dashed line.
#'
#' The index peak will be plotted as a vertical dashed line when it has been set using `assign_index_peaks()`.
#'
#'
#' @examples
#'
#' file_list <- instability::cell_line_fsa_list[1]
#'
#' test_ladders <- find_ladders(file_list)
#'
#' fragments_list <- find_fragments(test_ladders,
#'   min_bp_size = 300
#' )
#'
#' test_alleles <- find_alleles(
#'   fragments_list = fragments_list
#' )
#'
#' # Simple conversion from bp size to repeat size
#' test_repeats <- call_repeats(
#'   fragments_list = test_alleles
#' )
#'
#' plot_traces(test_repeats[1], xlim = c(105,150))
#'
#'
plot_traces <- function(fragments_list,
                        show_peaks = TRUE,
                        n_facet_col = 1,
                        sample_subset = NULL,
                        xlim = NULL,
                        ylim = NULL,
                        x_axis = NULL,
                        height_color_threshold = 0.05) {
  if (!is.null(sample_subset)) {
    fragments_list <- fragments_list[which(names(fragments_list) %in% sample_subset)]
  }

  graphics::par(mfrow = c(ceiling(length(fragments_list) / n_facet_col), n_facet_col)) # Adjust layout as needed
  for (i in seq_along(fragments_list)) {
    fragments_list[[i]]$plot_trace(
      show_peaks = show_peaks,
      xlim = xlim,
      ylim = ylim,
      x_axis = x_axis,
      height_color_threshold = height_color_threshold
    )
  }
  graphics::par(mfrow = c(1, 1)) # Reset the layout
}

# plot fragment data -------------------------------------------------------

#' Plot Peak Data
#'
#' Plots peak data from a list of fragments.
#'
#' @param fragments_list A list of fragments_repeats objects containing fragment data.
#' @param n_facet_col A numeric value indicating the number of columns for faceting in the plot.
#' @param sample_subset A character vector of unique ids for a subset of samples to plot
#' @param xlim the x limits of the plot. A numeric vector of length two.
#' @param ylim the y limits of the plot. A numeric vector of length two.
#'
#' @return A base R plot object displaying the peak data.
#' @export
#'
#' @examples
#' gm_raw <- instability::example_data
#'
#' test_fragments <- peak_table_to_fragments(gm_raw,
#'   data_format = "genemapper5",
#'   dye_channel = "B"
#' )
#'
#' test_alleles <- find_alleles(
#'   fragments_list = test_fragments,
#'   number_of_peaks_to_return = 2,
#'   peak_region_size_gap_threshold = 6,
#'   peak_region_height_threshold_multiplier = 1
#' )
#'
#' plot_fragments(test_alleles[1:2])
plot_fragments <- function(fragments_list,
                           n_facet_col = 2,
                           sample_subset = NULL,
                           xlim = NULL,
                           ylim = NULL) {
  if (!is.null(sample_subset)) {
    fragments_list <- fragments_list[which(names(fragments_list) %in% sample_subset)]
  }

  graphics::par(mfrow = c(ceiling(length(fragments_list) / n_facet_col), n_facet_col)) # Adjust layout as needed
  for (i in seq_along(fragments_list)) {
    fragments_list[[i]]$plot_fragments(
      xlim = xlim,
      ylim = ylim
    )
  }
  graphics::par(mfrow = c(1, 1)) # Reset the layout
}


# plot repeat correction model --------------------------------------------



#' Plot Repeat Correction Model
#'
#' Plots the results of the repeat correction model for a list of fragments.
#'
#' @param fragments_list A list of fragments_repeats class objects obtained from the 'call_repeats' function when the 'repeat_length_correction' was either 'from_metadata' or 'from_genemapper'.
#'
#' @return A base R graphic object displaying the repeat correction model results.
#' @export
#'
#' @examples
#'
#'
#' gm_raw <- instability::example_data
#' metadata <- instability::metadata
#'
#' test_fragments <- peak_table_to_fragments(
#'   gm_raw,
#'   data_format = "genemapper5",
#'   dye_channel = "B"
#' )
#'
#' test_alleles <- find_alleles(
#'   fragments_list = test_fragments,
#'   number_of_peaks_to_return = 2,
#'   peak_region_size_gap_threshold = 6,
#'   peak_region_height_threshold_multiplier = 1
#' )
#'
#' test_metadata <- add_metadata(
#'   fragments_list = test_alleles,
#'   metadata_data.frame = metadata
#' )
#'
#' test_repeats_corrected <- call_repeats(
#'   fragments_list = test_metadata,
#'   repeat_calling_algorithm = "simple",
#'   assay_size_without_repeat = 87,
#'   repeat_size = 3,
#'   repeat_length_correction = "from_metadata"
#' )
#'
#' plot_repeat_correction_model(test_repeats_corrected)
#'
plot_repeat_correction_model <- function(fragments_list) {
  # Check if all models in the list are the same
  first_model_df <- fragments_list[[1]]$.__enclos_env__$private$correction_mod$model
  identical_model_test <- logical(length(fragments_list))

  for (i in seq_along(fragments_list)) {
    identical_model_test[i] <- identical(first_model_df, fragments_list[[i]]$.__enclos_env__$private$correction_mod$model)
  }

  if (!all(identical_model_test)) {
    stop("The supplied fragments list must come from the same 'call_repeats' function output", call. = FALSE)
  }

  controls_repeats_df <- fragments_list[[1]]$.__enclos_env__$private$controls_repeats_df

  # Plotting
  graphics::par(mfrow = c(1, length(unique(controls_repeats_df$plate_id))))
  for (plate_id in unique(controls_repeats_df$plate_id)) {
    plate_data <- subset(controls_repeats_df, plate_id == plate_id)

    # Generating unique colors for each unique value in unique_id
    unique_ids <- unique(plate_data$unique_id)
    colors <- grDevices::rainbow(length(unique_ids))
    id_color_map <- setNames(colors, unique_ids)

    plot(plate_data$size, plate_data$validated_repeats,
      pch = 21, col = id_color_map[plate_data$unique_id],
      cex = 2, main = paste("Plate ID:", plate_id), xlab = "Size", ylab = "User supplied repeat length"
    )

    lm_model <- lm(validated_repeats ~ size, data = plate_data)
    graphics::abline(lm_model, col = "blue")
  }
}




# qmd templates -----------------------------------------------------------


#' Generate a Quarto file that has the instability pipeline preset
#'
#' @param file_name Name of file to create
#' @param size_standards Indicates if the functionality for correcting repeat size using size standards be included in the pipeline. See \code{\link{add_metadata}} & \code{\link{call_repeats}} for more info.
#' @param samples_grouped Indicates if the functionality for grouping samples for metrics calculations should be included in the pipeline. See \code{\link{add_metadata}} & \code{\link{assign_index_peaks}} for more info.
#'
#' @return A Quarto template file
#' @export
#'
#' @importFrom utils file.edit
#'
#' @examples
#'
#' if (interactive()) {
#'   generate_instability_template("test")
#' }
#'
#'
generate_instability_template <- function(
    file_name = NULL,
    size_standards = TRUE,
    samples_grouped = TRUE) {

  comment_out_lines <- function(content, start_pattern, end_pattern, comment_message = NULL) {
    start_idx <- grep(start_pattern, content)
    end_idx <- grep(end_pattern, content)[grep(end_pattern, content) > start_idx][1]

    if (length(start_idx) > 0 && length(end_idx) > 0) {
      content[(start_idx + 1):(end_idx - 1)] <- paste("#", content[(start_idx + 1):(end_idx - 1)])
      if (!is.null(comment_message)) {
        content <- append(content, comment_message, after = start_idx - 1)
      }
    }

    return(content)
  }

  if (is.null(file_name)) {
    stop("You must provide a valid file_name")
  }

  source_file <- system.file("extdata/_extensions/template.qmd", package = "instability")

  if (!file.exists(source_file)) {
    stop(paste("Source file does not exist:", source_file))
  }

  template_content <- readLines(source_file)

  if (!size_standards) {
    template_content <- gsub('metadata\\$plate_id <- metadata\\$plate_id', '# metadata$plate_id <- metadata$plate_id', template_content)
    template_content <- gsub('metadata\\$size_standard <- metadata\\$size_standard', '# metadata$size_standard <- metadata$size_standard', template_content)
    template_content <- gsub('metadata\\$size_standard_repeat_length <', '# metadata\\$size_standard_repeat_length <', template_content)
    template_content <- gsub('repeat_length_correction = "from_metadata"', 'repeat_length_correction = "none"', template_content)
    template_content <- gsub('plate_id = "plate_id"', 'plate_id = NA', template_content)
    template_content <- gsub('size_standard = "size_standard"', 'size_standard = NA', template_content)
    template_content <- gsub('size_standard_repeat_length = "size_standard_repeat_length"', 'size_standard_repeat_length = NA', template_content)
  }

  if (!samples_grouped) {
    template_content <- gsub('metadata\\$group_id <- metadata\\$group_id', '# metadata$group_id <- metadata$group_id', template_content)
    template_content <- gsub('metadata\\$metrics_baseline_control <- metadata\\$metrics_baseline_control', '# metadata$metrics_baseline_control <- metadata$metrics_baseline_control', template_content)
    template_content <- gsub('grouped = TRUE', 'grouped = FALSE', template_content)
    template_content <- gsub('group_id = "group_id"', 'group_id = NA', template_content)
    template_content <- gsub('metrics_baseline_control = "metrics_baseline_control"', 'metrics_baseline_control = NA', template_content)
  }

  if (!size_standards & !samples_grouped) {
    template_content <- gsub('metadata <- read.csv\\("")', '# metadata <- read.csv("")', template_content)
    template_content <- gsub('fragments_list = metadata_added_list', 'fragments_list = peak_list', template_content)

    # Comment out block of input section
    template_content <- comment_out_lines(template_content, '#Provide the appropriate metadata below by replacing the placeholders', "\\`\\`\\`")

    # Comment out the Add metadata section
    template_content <- comment_out_lines(template_content, "\\`\\`\\`\\{r Add metadata\\}", "\\`\\`\\`", "metadata not used")
  }

  writeLines(template_content, paste0(file_name, ".qmd"))
  file.edit(paste0(file_name, ".qmd"))
}












